---
title: Глоссарий Defold
brief: В этом руководстве с кратким описанием перечислено все, с чем вы сталкиваетесь при работе в Defold.
---

# Глоссарий Defold

В этом глоссарии дается краткое описание всех элементов и понятий, с которыми вы сталкиваетесь в Defold. В большинстве случаев вы найдете ссылку на более подробную документацию.

## Animation Set

![Animation set](images/icons/animationset.png){.left} "Animation Set" - это ресурс, содержащий список ``.dae``-файлов или других ``.animationset``-файлов, из которых можно считывать анимацию. Вложение одного ``.animationset``-файла в другой удобно, в случае, если вы используете частичные наборы анимации совместно между несколькими моделями. За подробностями обращайтесь к [Руководству по 3D-графике](/manuals/graphics/).

## Atlas

![Atlas](images/icons/atlas.png){.left} "Atlas" - это ресурс, представляющий собой набор отдельных изображений, которые по причинам производительности и эффективности использования памяти формируются на одном большом холсте. Может содержать неподвижные изображения или мультипликации. Ресурсы "Atlas" используются компонентами "GUI", "Sprite", "Spine" и "ParticleFX" с целью совместного использования графических ресурсов. Дополнительные сведения см. на стр. [Ресурс "Atlas"](/manuals/atlas).

## Builtins

![Builtins](images/icons/builtins.png){.left} Проектная папка ``builtins`` - это папка с атрибутом "только для чтения", содержащая полезные дефолтные ресурсы. Здесь вы найдете дефолтный рендер, рендер-скрипт, материалы и многое другое. Если вам нужны пользовательские изменения в любом из этих ресурсов, просто скопируйте их в свой проект и отредактируйте на свое умотрение.

## Camera

![Camera](images/icons/camera.png){.left} "Camera" - это компонент, помогающий определить, какая часть игрового мира должна быть видимой и как она должна быть спроецирована. Обычно используется для прикрепления камеры к объекту игрового персонажа или для создания отдельного игрового объекта с камерой, которая следует за игроком с каким-либо алгоритмом стабилизации движения. Дополнительную информацию см. на стр. [Компонент "Camera"](/manuals/camera).

## Collision Object

![Collision Object](images/icons/collision-object.png){.left} "Collision Object" - это компонент, расширяющий игровые объекты физическими свойствами (такими как пространственная форма, вес, трение и реституция). Эти свойства определяют, как объект столкновения должен сталкиваться с другими объектами столкновения. Наиболее распространенными типами объектов столкновения являются кинематические объекты, динамические объекты и триггеры. Кинематический объект дает подробную информацию о столкновении, на которую вы должны ответить вручную, динамический объект автоматически моделируется физическим движком, подчиняясь ньютоновским законам физики. Триггеры - это простые формы, которые определяют, вошли ли другие формы в триггер или вышли из него. Подробнее о том, как это работает, смотрите на стр. [Физика](/manuals/physics)

## Компоненты

Компоненты используются для придания определенной выразительности и/или функциональности (таких как графика, анимация, программируемое поведение и звук) игровым объектам. Они не существуют сами по себе, они должны содержаться внутри игровых объектов. В Defold существует множество доступных компонентов, описание которых см. на стр. [Блоки построения](/manuals/building-blocks).

## Collection

![Collection](images/icons/collection.png){.left} "Collection" - это механизм Defold для создания шаблонов, того, что в других движках называется "префабами", в которых иерархии игровых объектов могут быть использованы повторно. "Collection" - это древовидные структуры, в которых хранятся игровые объекты и другие коллекции. Всегда хранится в файле и вносится в игру либо статически, вручную средствами редактора, либо динамически, посредством порождения (spawning). Описание коллекций см. на стр. [Блоки построения](/manuals/building-blocks).

## Collection Factory

![Collection Factory](images/icons/collection-factory.png){.left} "Collection Factory" используется для динамического порождения иерархий игровых объектов в запущенной игре. Подробности см. на стр. [Collection factories](/manuals/collection-factory).

## "Collection Proxy"

![Collection](images/icons/collection.png){.left} "Collection Proxy" - это компонент, используемый для загрузки и включения коллекций на лету во время работы приложения или игры. Наиболее распространенным вариантом использования "Collection Proxy" является загрузка уровней по мере их вопроизведения. Подробности см. на стр. [Компонент "Collection Proxy"](/manuals/collection-proxy).

## Cubemap

![Cubemap](images/icons/cubemap.png){.left} "Cubemap" - это ресурс, представляющий собой особый тип текстуры, состоящий из 6 отдельных частей, отображаемых по аналогии со сторонами куба. Это удобно при рендеринге скайбоксов и различных видов карт отражения и освещения.

## Отладка

В какой-то момент ваша игра будет вести себя непредсказуемо, и вы должны выяснить, в чем заключается проблема. Научиться отлаживать - это искусство, и, к счастью, Defold поставляется со встроенным отладчиком, который поможет вам в этом. За подробностями обращайтесь к стр. [Отладка](/manuals/debugging).

## Display Profiles

![Display profiles](images/icons/display-profiles.png){.left} "Display Profiles" - это файл ресурса, используемый для определения компоновки графического интерфейса в зависимости от ориентации, соотношения сторон или модели устройства. Он помогает адаптировать пользовательский интерфейс для любого типа устройств. Подробнее см. на стр. [Компоновки](/manuals/gui-layouts).

## Factory

![Factory](images/icons/factory.png){.left} В некоторых ситуациях вы не сможете вручную разместить все необходимые игровые объекты в коллекции, и вам придется создавать игровые объекты динамически, на лету. Например, игрок может стрелять пулями, и каждый выстрел должен быть динамически порожден и отправлен, при нажатии игроком на спусковой механизм. Для динамического создания игровых объектов (из предварительно распределенного пула объектов) используется компонент "Factory". Подробности см. на стр. [Компонент "Factory"](/manuals/factory).

## Font

![Font file](images/icons/font.png){.left} "Font" - это ресурс, который создается из файла шрифтов TrueType или OpenType. "Font" определяет, какой размер и какой тип оформления (контур и тень) должен быть у визуализируемого шрифта. "Font" используется компонентами "GUI" и "Label". Подробности см. на стр. [Файлы шрифтов](/manuals/font/).

## Fragment shader

![Fragment shader](images/icons/fragment-shader.png){.left} Это программа, которая запускается на графическом процессоре для каждого пикселя (фрагмента) в полигоне, при отрисовке его на экране. Целью фрагментного шейдера является определение цвета каждого полученного фрагмента. Это делается путем вычисления, выборки текстур (по одной или несколько) или комбинации выборки и вычислений. Дополнительную информацию см. на стр. [Шейдеры](/manuals/shader).

## Gamepads

![Gamepads](images/icons/gamepad.png){.left} "Gamepads" - это файл ресурса, определяющий, как конкретный ввод устройства геймпада соотносится с вводом триггера геймпада на определенной платформе. Подробности см. на стр. [Ввод](/manuals/input).

## Game Object

![Game object](images/icons/game-object.png){.left} "Game Object" - это это простые объекты, которые имеют отдельную продолжительность жизни во время выполнения игры. "Game Object" - это контейнеры, которые обычно оснащены визуальными или звуковыми компонентами, такими как звук или спрайт. Они также могут быть оснащены поведением через компоненты сценария. Вы создаете игровые объекты и помещаете их в коллекции средствами редактора, либо динамически порождаете их в реальном времени посредством "Factory". Описание игровых объектов см. на стр. [Блоки построения](/manuals/building-blocks).

## GUI

![GUI component](images/icons/gui.png){.left} "GUI" - это компонент, содержащий элементы, используемые для построения пользовательских интерфейсов: текстовые и цветовые и/или текстурные блоки. Элементы могут быть организованы в иерархические структуры, заскриптованы и анимированны. Компоненты "GUI" обычно используются для создания HUD, систем меню и экранных уведомлений. Управляются с помощью GUI-скриптов, которые определяют поведение графического интерфейса и контролируют взаимодействие с ним пользователя. Подробнее см. на стр. [GUI](/manuals/gui).

## GUI Script

![GUI script](images/icons/script.png){.left} Для управления поведением компонентов графического интерфейса используются "GUI Script". Они управляют GUI-анимацией и взаимодействием пользователя с графическим интерфейсом. Подробнее о том, как скрипты Lua используются в Defold, смотрите на стр. [Lua в Defold](/manuals/lua).

## Горячая перезагрузка

Редактор Defold позволяет обновлять контент в уже запущенной игре, на рабочем столе и устройстве. Эта функция является чрезвычайно мощной и может повысить эффективность процесса разработки. Для получения более подробной информации обращайтесь к стр. [Горячая перезагрузка ресурсов](/manuals/hot-reload).

## Привязка ввода

![Input binding](images/icons/input-binding.png){.left} Файлы привязки ввода определяют, как игра должна интерпретировать аппаратный ввод (мышь, клавиатура, сенсорный экран и геймпад). Файл связывает аппаратный ввод с вводом высокого уровня _actions_ вида "jump" и "move_forward". В скриптовых компонентах, которые слушают ввод, вы можете написать сценарий действий, которые игра или приложение должно принять с учетом определенного ввода. Подробности см. на стр. [Ввод](/manuals/input).

## Label

![Label](images/icons/label.png){.left} "Label" - это компонент, позволяющий прикрепить текстовое содержимое к любому игровому объекту. Он отображает фрагмент текста с определенным шрифтом на экране в пространстве игры. Дополнительные сведения см. на стр. [Компонент "Label"](/manuals/label).

## Library

![Game object](images/icons/builtins.png){.left} Defold позволяет обмениваться данными между проектами с помощью мощного механизма библиотек. Вы можете использовать его для настройки общих библиотек, которые доступны из всех ваших проектов, как для себя, так и для всей команды. Подробнее о механизме работы библиотек см. на стр. [Библиотеки](/manuals/libraries).

## Язык Lua

Язык программирования Lua используется в Defold для создания логики игры. Lua - это мощный, эффективный и компактный скриптовый язык. Он поддерживает процедурное, объектно-ориентированное, функциональное программирование, программирование на основе данных и описание данных. Подробнее о языке можно прочитать на официальной домашней странице Lua по адресу https://www.lua.org/ и на стр. [Lua в Defold](/manuals/lua).

## Lua-модуль

![Lua module](images/icons/lua-module.png){.left} Lua-модули позволяют структурировать проект и создавать библиотечный код многоразового использования. Подробнее об этом читайте на стр. [Lua-модули](/manuals/modules/).

## Material

![Material](images/icons/material.png){.left} Материалы определяют, как должны быть визуализированы различные объекты, посредством определения шейдеров и их свойств. Для получения более подробной информации обращайтесь к стр. [Материалы](/manuals/material).

## Сообщение

Компоненты общаются друг с другом и с другими системами посредством передачи сообщений. Компоненты также реагируют на набор предопределенных сообщений, которые изменяют их или вызывают определенные действия. Вы отправляете сообщения, чтобы скрыть графику или подтолкнуть физические объекты. Движок также использует сообщения для уведомления компонентов о событиях, например, при столкновении физических форм. Механизму передачи сообщений необходим получатель для каждого отправленного сообщения. Поэтому все в игре адресовано уникально. Чтобы обеспечить связь между объектами, Defold расширяет Lua возможностью передачи сообщений. Defold также предоставляет библиотеку полезных функций.

Например, Lua-код, необходимый для того, чтобы скрыть компонент спрайта на игровом объекте, выглядит следующим образом:

```lua
msg.post("#weapon", "disable")
```

Здесь `"#weapon"` - это адрес компонента спрайта текущего объекта. `"disable"` - это сообщение, на которое реагируют компоненты спрайта. См. стр. [Передача сообщений](/manuals/message-passing) для более подробного объяснения того, как работает передача сообщений.

## Model

![Model](images/icons/model.png){.left} С помощью компонента "Model" можно импортировать в игру Collada-сетку, скелет и анимационные ассеты. Для получения дополнительной информации см. стр. [Компонент "Model"](/manuals/model/).

## ParticleFX

![ParticleFX](images/icons/particlefx.png){.left} Частицы очень полезны для создания приятных визуальных эффектов, особенно в играх. Вы можете использовать их для создания тумана, дыма, огня, дождя или падающих листьев. Defold содержит мощный редактор эффектов частиц, который позволяет создавать и корректировать эффекты, пока вы запускаете их в режиме реального времени в игре. Стр. [Компонент "ParticleFX"](/manuals/particlefx) даст вам подробную информацию о том, как это работает.

## Профилирование

Хорошая производительность является ключевым фактором в играх, и очень важно, чтобы вы могли выполнять профилирование производительности и памяти, чтобы оценить вашу игру и определить узкие места в производительности и проблемы с памятью, которые должны быть устранены. См. стр. [Профилирование](/manuals/profiling) для получения дополнительной информации об инструментах профилирования, доступных в Defold.

## Render

![Render](images/icons/render.png){.left} Файлы "Render" содержат настройки, используемые при рендеринге игры на экран. Файлы "Render" определяют, какой "Render Script" и какие материалы использовать для рендеринга. Подробнее см. на стр. [Render](/manuals/render/).

## Render Script

![Render script](images/icons/script.png){.left} "Render Script" - это Lua-скрипт, который управляет тем, как игра или приложение должны быть выведены на экран. Существует "Render Script" по умолчанию, который охватывает большинство распространенных случаев, но вы можете написать свой собственный, если вам нужны пользовательские модели освещения и других эффектов. Смотритеe стр. [Render](/manuals/render/) для получения более подробной информации о том, как работает процесс рендеринга, и [Lua в Defold](/manuals/lua) для получения более подробной информации о том, как Lua-скрипты используются в Defold.

## Script

![Script](images/icons/script.png){.left} "Script" - это компонент, который содержит программу, определяющую поведение игровых объектов. С помощью сценариев можно указать правила игры, как объекты должны реагировать на различные взаимодействия (как с игроком, так и с другими объектами). Все сценарии написаны на языке программирования Lua. Чтобы иметь возможность работать с Defold, вы или кто-то из вашей команды должен научиться программировать на Lua. См. стр. [Lua в Defold](/manuals/lua) для обзора Lua и подробностей о том, как Lua-скрипты используются в Defold.

## Sound

![Sound](images/icons/sound.png){.left} "Sound" - это компонет, отвечающий за воспроизведение определенного звука. В настоящее время Defold поддерживает звуковые файлы в форматах WAV и Ogg Vorbis. Дополнительную информацию см. на стр. [Sound](/manuals/sound).

## Spine Model

![Spine model](images/icons/spine-model.png){.left} "Spine Model" - это компонент, используемый для оживления скелетной Spine-анимации в Defold. Подробнее о том, как его использовать, читайте на стр. [Компонент "Spine Model"](/manuals/spinemodel).

## Spine Scene

![Spine scene](images/icons/spine-scene.png){.left} Ресурс "Spine Scene" связывает файл данных Spine JSON и файл атласа изображения Defold, который используется для заполнения слотов костей графикой. Страница [Spine-анимация](/manuals/spine) содержит более подробную информацию.

## Sprite

![Sprite](images/icons/sprite.png){.left} "Sprite" - это компонент, расширяющий игровые объекты графикой. Он отображает изображение либо из "Tile Source", либо из "Atlas". "Sprite" имеют встроенную поддержку флипбук и костевую анимацию. Обычно используются для персонажей и предметов.

## Texture Profiles

![Texture profiles](images/icons/texture-profiles.png){.left} "Texture Profiles" - это ресурс, используемый в процессе пакетирования для автоматической обработки и сжатия данных изображения (в "Atlas", "Tile Source", "Cubemap" и автономных текстурах, используемых для моделей, GUI и т.д.). Подробнее см. на стр. [Ресурс "Texture Profiles"](/manuals/texture-profiles).

## Tile Map

![Tile map](images/icons/tilemap.png){.left} "Tile Map" - это компонены, отображающие изображения из "Tile Source" в одной или нескольких перекрывающихся сетках. Они чаще всего используются для создания игровых сред: земли, стен, зданий и препятствий. "Tile Map" может отображать несколько слоев, выровненных друг над другом с заданным режимом смешивания. Это полезно, например, для нанесения листьев поверх травяных фоновых плиток. Также можно динамически изменять отображаемое изображение в плитке. Это позволяет, например, разрушить мост и сделать его непроходимым, просто заменив одну плитку на другую, изображающую разрушенный мост и содержащую соответствующую физическую форму. Дополнительную информацию см. на стр. [Компонент "Tile Map"](/manuals/tilemap).

## Tile Source

![Tile source](images/icons/tilesource.png){.left} "Tile Source" описывает текстуру, состоящую из нескольких уменьшенных изображений, каждое из которых имеет одинаковый размер. Вы можете определить флипбук-анимацию из последовательности изображений в "Tile Source". "Tile Source" также могут автоматически вычислять формы столкновений из данных изображений. Это очень полезно для создания уровней плитки, с которыми могут сталкиваться и взаимодействовать объекты. "Tile Source" используются компонентами "Tile Map" (а также "Sprite" и "ParticleFX") для совместного использования графических ресурсов. Обратите внимание, что "Atlas" часто подходит лучше, чем "Tile Source". См. стр. [Ресурс "Tile Source"](/manuals/tilemap).

## Vertex shader

![Vertex shader](images/icons/vertex-shader.png){.left} "Vertex shader" вычисляет экранную геометрию примитивных полигональных форм компонента. Для любого типа визуального компонента, будь то "Sprite", "Spine Model" или "Model", форма представлена набором позиций полигональных вершин. "Vertex shader" обрабатывает каждую вершину (в мировом пространстве) и вычисляет результирующую координату, которую должна иметь каждая вершина примитива. Дополнительную информацию см. на стр. [Шейдеры](/manuals/shader).
