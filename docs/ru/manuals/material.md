---
title: Материалы
brief: Данное руководство объясняет как работать с материалами, шейдерными константами и сэмплерами.
---

# Материалы

Материалы используются для выражения того, как графический компонент (спрайт, тайловая карта, шрифт, GUI-нода, модель и т.д.) должны быть отрендерены.

Метариал содержит _теги_, информацию, которая применяется конвейером рендеринга для отбора объектов для рендера. Также он содержит ссылку на _шейдерные программы_, которые компилируются через доступные графические драйверы и загружаются на графическое аппаратное обеспечение и запускаются в каждом кадре, когда компонент рендерится.

* Для большей информации по конвейеру рендеринга, смотрите [Документацию по рендеру](/manuals/render).
* Для глубого погружения в шейдерные программы, смотрите [Документацию по шейдерам](/manuals/shader).

## Создание материала

Чтобы создать материал, <kbd>кликните правой кнопкой мыши</kbd> по нужной папке в секции *Assets* и выберите <kbd>New... ▸ Material</kbd>. (Вы также можете выбрать <kbd>File ▸ New...</kbd> из меню и затем выбрать <kbd>Material</kbd>). Дайте имя новому файлу материала и нажмите <kbd>Ok</kbd>.

![Material file](images/materials/material_file.png){srcset="images/materials/material_file@2x.png 2x"}

Новый материал откроется в *Material Editor*.

![Material editor](images/materials/material.png){srcset="images/materials/material@2x.png 2x"}

Файл материала содержит следующую информацию:

Name
: То, что определяет материал. Это имя используется для перечисления материала в ресурсе *Render* для включения в билд. Имя также используется в функции из API рендеринга `render.enable_material()`. Имя должно быть уникальным.

Vertex Program
: Файл программы вершинного шейдера (*.vp*), который будет использоваться при рендеринге с этим материалом. Программа вершинного шейдера запускается на GPU для каждой из примитивных вершин компонента. Она вычисляет положение на экране для каждой вершины и также опционально подает на выход "изменяемые" переменные, которые интерполируются и идут на вход программе фрагментного шейдера.

Fragment Program
: Файл программы фрагментного шейдера (*.fp*), который будет использоваться при рендеринге с этим материалом. Программа запускается на GPU для каждого фрагмента (пикселя) графического примитива и ее цель --- это определить цвет отрисовки для каждого фрагмента. Обычно это делается на основе поиска по текстуре и вычислений на базе входящих переменных (изменяемые переменные либо константы).

Vertex Constants
: Нормированные значения (между 0.0 и 1.0), которые будут переданы программе вершинного шейдера. Смотрите ниже список доступных констант.

Fragment Constants
: Нормированные значения (между 0.0 и 1.0), которые будут переданы программе фрагментного шейдера. Смотрите ниже список доступных констант.

Samplers
: Опционально вы можете сконфигурировать специфичные сэмплеры в файле материалов. Добавьте сэмплер, назовите его согласно имени, используемому в программе шейдера и установите wrap и filter параметры по вашему вкусу. 

Tags
: Теги, ассоциированные с материалом. Теги представлены в движке как _битовая маска_, которая используется в [`render.predicate()`](/ref/render#render.predicate) для отбора компонентов, которые должны быть отрисованы вместе. Смотрите [Документацию по рендерингу](/manuals/render), описывающую как это делается. Максимальное число тегов, которое вы можете использовать в проекте --- 32.

## Вершинные и фрагментные константы

Шейдерные константы или "uniform"-ы --- это значения, которые передаются из движка в вершинные или фрагментные программы шейдеров. Для использования константы вы задаете ее в файле материала либо через свойство  *Vertex Constant* либо через свойство *Fragment Constant*. Соответствующие `uniform` переменные должны быть определены в программе шейдера. Следующие константы могут быть установлены в материале:

CONSTANT_TYPE_WORLD
: Мировая матрица. Используйте ее для преобразования вершин в пространство мира. Для некоторых типов компонентов, вершины уже расположены в пространстве мира, когда они отправляются вершинной программе (в виду пакетирования). В таких случаях, умножение на мировую матрицу в шейдере выдаст некорректные результаты.

CONSTANT_TYPE_VIEW
: Матрица вида. Используйте ее для преобразования вершин в пространство отображения (камеры).

CONSTANT_TYPE_PROJECTION
: Проекционная матрица. Используйте ее для преобразования вершин в пространство экрана.

CONSTANT_TYPE_VIEWPROJ
: Матрица с уже перемноженными матрицей вида и проекционной матрицы.

CONSTANT_TYPE_WORLDVIEW
: Матрица с уже перемноженными матрицей мира и предыдущей матрицы (перемножение матрицы вида на проекционную).

CONSTANT_TYPE_NORMAL
: Матрица для вычисления ориентации по нормали. Мировое преобразование может включать не-нормированное (non-uniform) масштабирование, которое ломает ортогональность скомбинированного мир-на-отображение преобразования. Матрица нормалей используется, чтобы избежать проблем с направлениями когда преобразовываются нормали. (Нормальная матрица --- это транспонированная инверсия матрицы мир-на-отображение.)  

CONSTANT_TYPE_USER
: Константа типа vector4, которую вы можете использовать для любых собственных данных, которые вы хотите передать в программу шейдера. Вы можете установить начальное значение константы в месте ее определения, но она изменяема через функции [go.set()](/ref/stable/go/#go.set) / [go.animate()](/ref/stable/go/#go.animate). Также вы можете получить ее значение через [go.get()](/ref/stable/go/#go.get). Изменение константы материала одного экземпляра компонента [ломает пакетирование для рендеринга и приведет к дополнительным вызовам отрисовки](/manuals/render/#draw-calls-and-batching).
<br>Example:
```lua
go.set("#sprite", "tint", vmath.vector4(1,0,0,1))

go.animate("#sprite", "tint", go.PLAYBACK_LOOP_PINGPONG, vmath.vector4(1,0,0,1), go.EASING_LINEAR, 2)
```

## Сэмплеры

Сэмплеры используются для отбора цветовой информации из текстуры (тайловый источник или атлас). Цветовая информация может далее быть использована для вычислений в программе шейдера.

Компоненты типа спрайт, тайловая карта, GUI или эффект частиц автоматически получают набор `sampler2D`. Первый объявленный `sampler2D` в программе шейдера автоматически привязывается к изображению, на которое ссылается графический компонент. Поэтому сейчас нет необходимости указывать какие-либо сэмплеры в файле материалов для этих компонентов. Более того, эти типы компонентов сейчас поддерживают только одну текстуру. (Если вам нужно множество текстур в шейдере, вы можете использовать вызов [`render.enable_texture()`](/ref/render/#render.enable_texture) и устанавливать текстурные сэмплеры вручную из своего рендер скрипта.)

![Sprite sampler](images/materials/sprite_sampler.png){srcset="images/materials/sprite_sampler@2x.png 2x"}

```glsl
-- mysprite.fp
varying mediump vec2 var_texcoord0;
uniform lowp sampler2D MY_SAMPLER;
void main()
{
    gl_FragColor = texture2D(MY_SAMPLER, var_texcoord0.xy);
}
```

Вы можете задать настройки сэмплера для компонента добавив сэмплер по имени в файле материалов. Если вы не устанавливаете свой сэмплер в файле материалов, будут использованы глобальные настройки *graphics* проекта. 

![Sampler settings](images/materials/my_sampler.png){srcset="images/materials/my_sampler@2x.png 2x"}

Для компонентов типа модель, вам необходимо задать ваши сэмплеры в файле материала с теми настройками, которые вы хотите. Далее после этих действий редактор позволит вам выставить текстуры для любого модельного компонента, который использует этот материал:

![Model samplers](images/materials/model_samplers.png){srcset="images/materials/model_samplers@2x.png 2x"}

```glsl
-- mymodel.fp
varying mediump vec2 var_texcoord0;
uniform lowp sampler2D TEXTURE_1;
uniform lowp sampler2D TEXTURE_2;
void main()
{
    lowp vec4 color1 = texture2D(TEXTURE_1, var_texcoord0.xy);
    lowp vec4 color2 = texture2D(TEXTURE_2, var_texcoord0.xy);
    gl_FragColor = color1 * color2;
}
```

![Model](images/materials/model.png){srcset="images/materials/model@2x.png 2x"}

## Настройки сэмплера

Name
: Имя сэмплера. Это имя должно совпадать с заданной в фрагментном шейдере `sampler2D` переменной.

Wrap U/W
: Режим развертки для осей U и V:

  - `WRAP_MODE_REPEAT` -- повторит данные текстуры вне диапазона [0,1].
  - `WRAP_MODE_MIRRORED_REPEAT` -- повторит данные текстуры вне диапазона [0,1], но каждое второе повторение будет зеркально отражено.
  - `WRAP_MODE_CLAMP_TO_EDGE` --- будет приводить данные текстуры со значениями больше 1.0 к значению 1.0, а любые значения меньше 0.0 будут приводиться к значению 0.0 --- то есть крайние пиксели будут повторяться до края.

Filter Min/Mag
: Фильтрация для увеличения и уменьшения. Ближайшая фильтрация требует меньше вычислений, чем линейная интерполяция, но может привести к артефактам алиасинга. Линейная интерполяция часто дает более плавные результаты :

  - `FILTER_MODE_NEAREST` -- использует тексель с координатами ближайшими к центру пикселя.
  - `FILTER_MODE_LINEAR` -- устанавливает взвешенное линейное среднее для массива текселей 2x2, которые лежат ближе всего к центру пикселя .
  - `FILTER_MODE_NEAREST_MIPMAP_NEAREST` -- выбирает ближайшее значение текселя в отдельной MIP-карте.
  - `FILTER_MODE_NEAREST_MIPMAP_LINEAR` -- выбирает ближайший тексель из двух ближайших лучших вариантов MIP-карт и затем линейно интерполирует между этими двумя значениями.
  - `FILTER_MODE_LINEAR_MIPMAP_NEAREST` -- линейное интерполирование в пределах отдельной MIP-карты. 
  - `FILTER_MODE_LINEAR_MIPMAP_LINEAR` -- использует линейную интерполяцию для вычисления значения на каждой из двух карт, а затем выполняет линейную интерполяцию между этими двумя значениями.

## Буферы констант

Когда конвейер рендеринга отрисовывает, он берет значения констант из буфера по-умолчанию --- системного буфера констант. Вы можете создать собственный буфер констант, чтобы перекрыть константы по-умолчанию и вместо этого выставить uniform-ы для программы шейдера программно в рендер скрипте:

```lua
self.constants = render.constant_buffer() -- <1>
self.constants.tint = vmath.vector4(1, 0, 0, 1) -- <2>
...
render.draw(self.my_pred, self.constants) -- <3>
```
1. Создаем новый буфер констант
2. Устанавливаем константу `tint` в ярко-красный
3. Рисуем предикат используя наши собственные константы

Учтите, что элементы констант буфера ссылаются как обычная Lua таблица, но вы не можете итерироваться по буферу с помощью вызовов `pairs()` или `ipairs()`.
